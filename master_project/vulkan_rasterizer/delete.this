#pragma once

#include <cstdint>
#include <vector>
#include <cassert>

enum class SplitAxis
{
	dim_x = 0,
	dim_y = 1,
	dim_z = 2,
	leafNode = 3,

	enum_size
};

struct NodeIndex
{
	uint32_t internalIndex;
};

struct NodePairIndex
{
	NodeIndex internalLeftIndex;
	constexpr NodeIndex GetLeftIndex() const { return  internalLeftIndex; };
	constexpr NodeIndex GetRightIndex() const { return NodeIndex{ internalLeftIndex.internalIndex + 1 }; };
};

struct DataIndex
{
	uint32_t internalIndex;
};

struct DataIndexView
{
	DataIndex firstIndex;
	uint32_t size;
};

class KdNode
{
public:
	SplitAxis GetSplitAxis() const noexcept;
	NodePairIndex GetChildNodeIndexPair() const noexcept;
	DataIndexView GetLeaveIndexView() const noexcept;
	const float GetSplitVal() const noexcept;

	static KdNode CreateNode(NodePairIndex childNodes, SplitAxis splitAxis, float splitVal);
	static KdNode CreateLeaf(DataIndexView dataIndexView);

private:
	uint32_t GetIndex() const noexcept;

	// split axis, and either DataIndex or NodeIndex depending on split axis value
	uint32_t indexAndSplitAxis;

	static constexpr int splitAxisBits = 2;
	static_assert((1 << splitAxisBits) <= static_cast<int>(SplitAxis::enum_size));

	static constexpr int splitAxisRightShifts = sizeof(uint32_t) * CHAR_BIT - splitAxisBits;
	static constexpr uint32_t splitAxisMask = (~uint32_t(0)) << splitAxisRightShifts;
	static constexpr uint32_t indexMask = ~splitAxisMask;

	union FloatOrUInt32
	{
		float splitVal;
		uint32_t dataViewSize;
	};

	FloatOrUInt32 splitValOrDataViewSize;
};

static_assert(sizeof(KdNode) == sizeof(uint32_t) * 2);

 SplitAxis KdNode::GetSplitAxis() const {
	 uint32_t splitAxisVal = (indexAndSplitAxis >> splitAxisRightShifts);
	 assert(splitAxisVal < static_cast<uint32_t>(SplitAxis::enum_size));
	 return static_cast<SplitAxis>(splitAxisVal);
 };

uint32_t KdNode::GetIndex() const noexcept
{
	return indexAndSplitAxis & indexMask;
}

NodePairIndex KdNode::GetChildNodeIndexPair() const noexcept
{
	assert(GetSplitAxis() != SplitAxis::leafNode);
	return NodePairIndex{ GetIndex() };
}

const float KdNode::GetSplitVal() const noexcept
{

	assert(GetSplitAxis() != SplitAxis::leafNode);
	return splitValOrDataViewSize.splitVal;
}

DataIndexView KdNode::GetLeaveIndexView() const noexcept
{
	assert(GetSplitAxis() == SplitAxis::leafNode);
	const uint32_t index = GetIndex();
	const uint32_t size = splitValOrDataViewSize.dataViewSize;

	return DataIndexView{ index, size };
}

KdNode KdNode::CreateNode(NodePairIndex childNodes, SplitAxis splitAxis, float splitVal)
{
	const uint32_t splitAxis_shifted = (static_cast<uint32_t>(SplitAxis::leafNode)) << splitAxisRightShifts;

	KdNode result;
	result.indexAndSplitAxis = childNodes.internalLeftIndex.internalIndex | splitAxis_shifted;
	result.splitValOrDataViewSize.splitVal = splitVal;
	return result;
}

KdNode KdNode::CreateLeaf(DataIndexView dataIndexView)
{
	constexpr uint32_t leafNode = (static_cast<uint32_t>(SplitAxis::leafNode)) << splitAxisRightShifts;
	static_assert((leafNode & splitAxisMask) != 0);

	assert((dataIndexView.firstIndex.internalIndex & splitAxisMask) == 0 && "data index view index too large");

	KdNode result;
	result.indexAndSplitAxis = dataIndexView.firstIndex.internalIndex | leafNode;
	result.splitValOrDataViewSize.dataViewSize = dataIndexView.size;
	return result;
}



// storage for our KdTree, we can optimize this later
class KdNodeMemory
{
	NodePairIndex AllocNodePair();

	KdNode& Access(NodeIndex index) { return m_nodes[index.internalIndex]; }
	const KdNode& Get(NodeIndex index) const { return m_nodes[index.internalIndex]; }


private:
	std::vector<KdNode> m_nodes;
};


NodePairIndex KdNodeMemory::AllocNodePair()
{
	int internalLeftIndex = static_cast<int>(m_nodes.size());

	// add two nodes
	m_nodes.emplace_back();
	m_nodes.emplace_back();

	return NodePairIndex{ internalLeftIndex };
}


